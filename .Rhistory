require(devtools)
install_github("keisuke-hanada/metaMest")
metaMest::rand_tau2dl_tau2(n=100, K=3, tau2=2, sig2k=1:3)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
#'@param vi vector of length K with the corresponding sample variances.
#'@param theta value of true overall effect that define 0 in default.
#'@param tau2 value of estimated between-study variance.
#'@param tau2b vector of candidate values of M-estimator based parameter. If the default is insufficient, the search area can be increased by increasing the upper limit or narrowing the interval.
#'@param n.tau2 value of number of sampling for estimates of between-study variance.
#'@param method character string to specify the estimating method of between-study variance. By default (method="DL"), DerSimonian-Laird estimator is obtained. When method="SJ", Sidik-Jonkman estimator is obtained. When method="HKSJ-DL", DerSimonian-Laird method with HKSJ approach is obtained. When method="HKSJ-SJ", Sidik-Jonkman method with HKSJ approach is obtained.
#'
#'@return Probability of qval and M-estimator based estimates of location parameter.
#'
#'@export
ptheta_with_M_estimator <- function(qval, yi, vi, theta=0, tau2, tau2b=c(0.001,1:300/10), n.tau2=10000, method="DL"){
rho <- function(u, func=1){
if(func==1){
return(abs(u))
}else if(func==2){
return(u^2)
}else{
return(u)
}
}
estfun <- function(tau2b, x, func=1){
n.tau2b <- length(tau2b)
R <- array(10000, dim=n.tau2b)
for(i.tau2m in 1:n.tau2b){
R_tau2b <- array(10000, dim=n.tau2b)
for(i.tau2b in 1:n.tau2b){
R_tau2b[i.tau2b] <- mean(rho(x[,i.tau2m] - tau2b[i.tau2b], func))
}
R[i.tau2m] <- tau2b[which.min(R_tau2b)]
}
return(R)
}
K <- length(vi)
if(method=="DL"){
DLestfun <- function(tau2dl, K, vi, n.tau2hat=10000, func=1, tmin=0, tmax=10000){
R <- function(tau2){
rval <- optimize(f=function(val, n.tau2hat, K, vi, func=func){
x <- rand_tau2dl_tau2(n=n.tau2hat, K=K, tau2=tau2, sig2k=vi)
return( mean(rho(x - val)) )
}, n.tau2hat=n.tau2hat, K=K, vi=vi, func=func, interval=c(tmin,tmax))$minimum
return(rval)
}
if(tau2dl - R(tmin)<=0){
return(tmin)
}else{
return(
uniroot(f=function(tau2, tau2dl){
return(tau2dl - R(tau2))
}, tau2dl=tau2dl, interval=c(tmin, tmax))$root
)
}
}
tau2m <- DLestfun(tau2dl, K=K, vi=sig2k, n.tau2hat=n.tau2hat)
x.m <- rand_tau2dl_tau2(n=n.tau2, K=K, tau2=tau2m, sig2k=vi)
v2 <- numeric(n.tau2)
for(k in 1:K){
v2 <- v2 + 1/(vi[k]+x.m)
}
v2 <- 1/v2
qy <- sapply(qval, function(yval){mean(stats::pnorm(yval, mean=theta, sd=sqrt(v2)))})
}else if(method=="SJ"){
x <- sapply(tau2b, function(x){ x/(K-1)*stats::rchisq(n.tau2, df=K-1) })
R <- estfun(tau2b, x, func=1)
vk_m <- sapply(1:K, function(k){1 + vi[k]/tau2b})
theta_vm <- apply(yi/t(vk_m), 2, sum) / apply(1/vk_m, 1, sum)
tau2sj_m <- apply( (t(array(yi, dim=c(K,length(tau2b))))-theta_vm)^2/vk_m, 1, sum) / (K-1)
tau2m_sj_num <- which.min(abs(R-tau2sj_m))
tau2m <- tau2b[tau2m_sj_num]
x.m <- x[,tau2m_sj_num]
v2 <- numeric(n.tau2)
for(k in 1:K){
v2 <- v2 + 1/(vi[k]+x.m)
}
v2 <- 1/v2
qy <- sapply(qval, function(yval){mean(stats::pnorm(yval, mean=0, sd=sqrt(v2)))})
}else if(method=="HKSJ-DL"){
x <- rand_tau2dl_tau2(n=n.tau2, K=K, tau2=tau2b, sig2k=vi)
R <- estfun(tau2b, x, func=1)
tau2m <- tau2b[which.min(abs(R-tau2))]
x.m <- x[,which.min(abs(R-tau2))]
wk_m <- sapply(1:K, function(k){1/(vi[k]+x.m)})
theta_hksj_m <- apply(t(wk_m)*yi, 2, sum) / apply(wk_m, 1, sum)
v2_hksj_m <- apply(wk_m*(t(array(yi,dim=c(K, n.tau2)))-theta_hksj_m)^2, 1, sum) / ((K-1)*apply(wk_m, 1, sum))
qy <- sapply(qval, function(yval){mean(stats::pt(q=(yval-theta_hksj_m)/sqrt(v2_hksj_m), df=K-1))})
}else if(method=="HKSJ-SJ"){
x <- sapply(tau2b, function(x){ x/(K-1)*stats::rchisq(n.tau2, df=K-1) })
R <- estfun(tau2b, x, func=1)
vk_m <- sapply(1:K, function(k){1 + vi[k]/tau2b})
theta_vm <- apply(yi/t(vk_m), 2, sum) / apply(1/vk_m, 1, sum)
tau2sj_m <- apply( (t(array(yi, dim=c(K,length(tau2b))))-theta_vm)^2/vk_m, 1, sum) / (K-1)
tau2m_sj_num <- which.min(abs(R-tau2sj_m))
tau2m <- tau2b[tau2m_sj_num]
x.m <- x[,tau2m_sj_num]
wk_m <- sapply(1:K, function(k){1/(vi[k]+x.m)})
theta_hksj_m <- apply(t(wk_m)*yi, 2, sum) / apply(wk_m, 1, sum)
v2_hksj_m <- apply(wk_m*(t(array(yi,dim=c(K, n.tau2)))-theta_hksj_m)^2, 1, sum) / ((K-1)*apply(wk_m, 1, sum))
qy <- sapply(qval, function(yval){mean(stats::pt(q=(yval-theta_hksj_m)/sqrt(v2_hksj_m), df=K-1))})
}else{
stop("Method should be DL, SJ, HKSJ-DL or HKSJ-SJ")
}
return(list(qy=qy, tau2m=tau2m))
}
#'Sampling from exact distribution of DerSimonian-Laird between-study variance estimator
#'
#'@param n number of sampling
#'@param K number of studies
#'@param tau2 between-study variance parameter
#'@param sig2k within-study variance in each study
#'
#'@return sampling values from exact distribution of DerSimonian-Laird between-study variance estimator
#'
#'@export
rand_tau2dl_tau2 <- function(n, K, tau2, sig2k){
s1 <- sum(1/sig2k)
s2 <- sum(1/sig2k^2)
chi_sim <- array(0, dim=c(K,n))
for(i in 1:K){
chi_sim[i,] <- stats::rchisq(n=n, df=1)
}
W <- diag(x=1/sig2k,nrow=K,ncol=K)
x_ftau20 <- array(0, dim=c(length(tau2), n))
for(i.b in 1:length(tau2)){
V <- U <- array(0, dim=c(K,K))
lambda <- array(0, dim=c(K))
for(i in 1:K){
for(j in 1:K){
V[i,j] <- -1/s1 + (s2/s1^2 - (1/sig2k[i]+1/sig2k[j])/s1)*tau2[i.b]
}
V[i,i] <- (sig2k[i] - 1/s1) + (1 + s2/s1^2 - 2/sig2k[i]/s1)*tau2[i.b]
}
U <- V %*% W
lambda <- eigen(U)$value
Q_chis <- c(lambda %*% chi_sim)
x_ftau20[i.b,] <- (Q_chis - (K-1)) / (s1-s2/s1) # f(tau2hat|tau2b)からのサンプル, 0以下の補正なし
}
x_ftau2 <- x_ftau20
x_ftau2[x_ftau2<0] <- 0
return(t(x_ftau2))
}
library(metafor)
library(rma.exact)
set.seed(1234)
dat01 <- read.xlsx(xlsxFile = "JIA.xlsx")
yk <- dat01$logOR
sig2k <- dat01$SD^2
# install.packages("openxlsx")
# install.packages("metafor")
# install.packages("rma.exact")
library(openxlsx)
dat01 <- read.xlsx(xlsxFile = "JIA.xlsx")
library(metaMest)
library(metaMest)
rho <- function(u, func=1){
if(func==1){
return(abs(u))
}else if(func==2){
return(u^2)
}else{
return(u)
}
}
estfun <- function(tau2b, x, func=1){
n.tau2b <- length(tau2b)
R <- array(10000, dim=n.tau2b)
for(i.tau2m in 1:n.tau2b){
R_tau2b <- array(10000, dim=n.tau2b)
for(i.tau2b in 1:n.tau2b){
R_tau2b[i.tau2b] <- mean(rho(x[,i.tau2m] - tau2b[i.tau2b], func))
}
R[i.tau2m] <- tau2b[which.min(R_tau2b)]
}
return(R)
}
K <- length(vi)
yi
yi=1:3
vi=1:3
tau2
DLestfun <- function(tau2dl, K, vi, n.tau2hat=10000, func=1, tmin=0, tmax=10000){
R <- function(tau2){
rval <- optimize(f=function(val, n.tau2hat, K, vi, func=func){
x <- rand_tau2dl_tau2(n=n.tau2hat, K=K, tau2=tau2, sig2k=vi)
return( mean(rho(x - val)) )
}, n.tau2hat=n.tau2hat, K=K, vi=vi, func=func, interval=c(tmin,tmax))$minimum
return(rval)
}
if(tau2dl - R(tmin)<=0){
return(tmin)
}else{
return(
uniroot(f=function(tau2, tau2dl){
return(tau2dl - R(tau2))
}, tau2dl=tau2dl, interval=c(tmin, tmax))$root
)
}
}
wk <- 1/vi
thetabar0 <- sum(yi*wk)/sum(wk)
Q <- sum(wk*(yi-thetabar0)^2)
tau2u <- (Q-(K-1))/(sum(wk)-sum(wk^2)/sum(wk))
tau2dl <- max(0, tau2u)
tau2m <- DLestfun(tau2dl, K=K, vi=sig2k, n.tau2hat=n.tau2hat)
tau2m <- DLestfun(tau2dl, K=K, vi=vi, n.tau2hat=n.tau2hat)
n.tau2=1000
tau2m <- DLestfun(tau2dl, K=K, vi=vi, n.tau2hat=n.tau2)
x.m <- rand_tau2dl_tau2(n=n.tau2, K=K, tau2=tau2m, sig2k=vi)
v2 <- numeric(n.tau2)
for(k in 1:K){
v2 <- v2 + 1/(vi[k]+x.m)
}
v2 <- 1/v2
qy <- sapply(qval, function(yval){mean(stats::pnorm(yval, mean=theta, sd=sqrt(v2)))})
qval=1:10
qy <- sapply(qval, function(yval){mean(stats::pnorm(yval, mean=theta, sd=sqrt(v2)))})
theta=0
qy <- sapply(qval, function(yval){mean(stats::pnorm(yval, mean=theta, sd=sqrt(v2)))})
qy
library(metaMest)
#'@param vi vector of length K with the corresponding sample variances.
#'@param theta value of true overall effect that define 0 in default.
#'@param tau2 value of estimated between-study variance.
#'@param tau2b vector of candidate values of M-estimator based parameter. If the default is insufficient, the search area can be increased by increasing the upper limit or narrowing the interval.
#'@param n.tau2 value of number of sampling for estimates of between-study variance.
#'@param method character string to specify the estimating method of between-study variance. By default (method="DL"), DerSimonian-Laird estimator is obtained. When method="SJ", Sidik-Jonkman estimator is obtained. When method="HKSJ-DL", DerSimonian-Laird method with HKSJ approach is obtained. When method="HKSJ-SJ", Sidik-Jonkman method with HKSJ approach is obtained.
#'
#'@return Probability of qval and M-estimator based estimates of location parameter.
#'
#'@export
ptheta_with_M_estimator <- function(qval, yi, vi, theta=0, tau2, tau2b=c(0.001,1:300/10), n.tau2=10000, method="DL"){
rho <- function(u, func=1){
if(func==1){
return(abs(u))
}else if(func==2){
return(u^2)
}else{
return(u)
}
}
estfun <- function(tau2b, x, func=1){
n.tau2b <- length(tau2b)
R <- array(10000, dim=n.tau2b)
for(i.tau2m in 1:n.tau2b){
R_tau2b <- array(10000, dim=n.tau2b)
for(i.tau2b in 1:n.tau2b){
R_tau2b[i.tau2b] <- mean(rho(x[,i.tau2m] - tau2b[i.tau2b], func))
}
R[i.tau2m] <- tau2b[which.min(R_tau2b)]
}
return(R)
}
K <- length(vi)
if(method=="DL"){
DLestfun <- function(tau2dl, K, vi, n.tau2hat=10000, func=1, tmin=0, tmax=10000){
R <- function(tau2){
rval <- optimize(f=function(val, n.tau2hat, K, vi, func=func){
x <- rand_tau2dl_tau2(n=n.tau2hat, K=K, tau2=tau2, sig2k=vi)
return( mean(rho(x - val)) )
}, n.tau2hat=n.tau2hat, K=K, vi=vi, func=func, interval=c(tmin,tmax))$minimum
return(rval)
}
if(tau2dl - R(tmin)<=0){
return(tmin)
}else{
return(
uniroot(f=function(tau2, tau2dl){
return(tau2dl - R(tau2))
}, tau2dl=tau2dl, interval=c(tmin, tmax))$root
)
}
}
wk <- 1/vi
thetabar0 <- sum(yi*wk)/sum(wk)
Q <- sum(wk*(yi-thetabar0)^2)
tau2u <- (Q-(K-1))/(sum(wk)-sum(wk^2)/sum(wk))
tau2dl <- max(0, tau2u)
tau2m <- DLestfun(tau2dl=tau2dl, K=K, vi=vi, n.tau2hat=n.tau2)
x.m <- rand_tau2dl_tau2(n=n.tau2, K=K, tau2=tau2m, sig2k=vi)
v2 <- numeric(n.tau2)
for(k in 1:K){
v2 <- v2 + 1/(vi[k]+x.m)
}
v2 <- 1/v2
qy <- sapply(qval, function(yval){mean(stats::pnorm(yval, mean=theta, sd=sqrt(v2)))})
}else if(method=="SJ"){
x <- sapply(tau2b, function(x){ x/(K-1)*stats::rchisq(n.tau2, df=K-1) })
R <- estfun(tau2b, x, func=1)
vk_m <- sapply(1:K, function(k){1 + vi[k]/tau2b})
theta_vm <- apply(yi/t(vk_m), 2, sum) / apply(1/vk_m, 1, sum)
tau2sj_m <- apply( (t(array(yi, dim=c(K,length(tau2b))))-theta_vm)^2/vk_m, 1, sum) / (K-1)
tau2m_sj_num <- which.min(abs(R-tau2sj_m))
tau2m <- tau2b[tau2m_sj_num]
x.m <- x[,tau2m_sj_num]
v2 <- numeric(n.tau2)
for(k in 1:K){
v2 <- v2 + 1/(vi[k]+x.m)
}
v2 <- 1/v2
qy <- sapply(qval, function(yval){mean(stats::pnorm(yval, mean=0, sd=sqrt(v2)))})
}else if(method=="HKSJ-DL"){
x <- rand_tau2dl_tau2(n=n.tau2, K=K, tau2=tau2b, sig2k=vi)
R <- estfun(tau2b, x, func=1)
tau2m <- tau2b[which.min(abs(R-tau2))]
x.m <- x[,which.min(abs(R-tau2))]
wk_m <- sapply(1:K, function(k){1/(vi[k]+x.m)})
theta_hksj_m <- apply(t(wk_m)*yi, 2, sum) / apply(wk_m, 1, sum)
v2_hksj_m <- apply(wk_m*(t(array(yi,dim=c(K, n.tau2)))-theta_hksj_m)^2, 1, sum) / ((K-1)*apply(wk_m, 1, sum))
qy <- sapply(qval, function(yval){mean(stats::pt(q=(yval-theta_hksj_m)/sqrt(v2_hksj_m), df=K-1))})
}else if(method=="HKSJ-SJ"){
x <- sapply(tau2b, function(x){ x/(K-1)*stats::rchisq(n.tau2, df=K-1) })
R <- estfun(tau2b, x, func=1)
vk_m <- sapply(1:K, function(k){1 + vi[k]/tau2b})
theta_vm <- apply(yi/t(vk_m), 2, sum) / apply(1/vk_m, 1, sum)
tau2sj_m <- apply( (t(array(yi, dim=c(K,length(tau2b))))-theta_vm)^2/vk_m, 1, sum) / (K-1)
tau2m_sj_num <- which.min(abs(R-tau2sj_m))
tau2m <- tau2b[tau2m_sj_num]
x.m <- x[,tau2m_sj_num]
wk_m <- sapply(1:K, function(k){1/(vi[k]+x.m)})
theta_hksj_m <- apply(t(wk_m)*yi, 2, sum) / apply(wk_m, 1, sum)
v2_hksj_m <- apply(wk_m*(t(array(yi,dim=c(K, n.tau2)))-theta_hksj_m)^2, 1, sum) / ((K-1)*apply(wk_m, 1, sum))
qy <- sapply(qval, function(yval){mean(stats::pt(q=(yval-theta_hksj_m)/sqrt(v2_hksj_m), df=K-1))})
}else{
stop("Method should be DL, SJ, HKSJ-DL or HKSJ-SJ")
}
return(list(qy=qy, tau2m=tau2m))
}
library(metaMest)
getwd()
setwd("C:/Users/keihb/Dropbox/研究/010_論文化検討/2024_01_quantile based between-study variance/02_program/paper-analysis/")
# install.packages("openxlsx")
# install.packages("metafor")
# install.packages("rma.exact")
library(openxlsx)
library(metafor)
library(rma.exact)
set.seed(1234)
dat01 <- read.xlsx(xlsxFile = "JIA.xlsx")
yk <- dat01$logOR
sig2k <- dat01$SD^2
K <- length(yk)
alpha <- 0.05
dl <- rma.uni(yi=yk, vi=sig2k, method="DL")
sj <- rma.uni(yi=yk, vi=sig2k, method="SJ")
# DL
dl.orci <- c(exp(dl$ci.lb), exp(dl$ci.ub))
# SJ
sj.orci <- c(exp(sj$ci.lb), exp(sj$ci.ub))
# HKSJ-DL
wk_tau2dl <- sapply(1:K, function(k){1/(sig2k[k]+dl$tau2)})
v2_hksj <- sum(wk_tau2dl*(yk-as.numeric(dl$b))^2) / ((K-1)*sum(wk_tau2dl))
cildl_hksj <- dl$b + qt(alpha/2, df=K-1) * sqrt(v2_hksj)
ciudl_hksj <- dl$b + qt(1-alpha/2, df=K-1) * sqrt(v2_hksj)
ci_hksj_dl <- c(cildl_hksj, ciudl_hksj)
# HKSJ-SJ
wk_tau2sj <- sapply(1:K, function(k){1/(sig2k[k]+sj$tau2)})
v2_hksj <- sum(wk_tau2dl*(yk-as.numeric(sj$b))^2) / ((K-1)*sum(wk_tau2sj))
cilsj_hksj <- sj$b + qt(alpha/2, df=K-1) * sqrt(v2_hksj)
ciusj_hksj <- sj$b + qt(1-alpha/2, df=K-1) * sqrt(v2_hksj)
ci_hksj_sj <- c(cilsj_hksj, ciusj_hksj)
# DL with M-estimator
y <- 1:1000/1000
pval_dl <- ptheta_with_M_estimator(qval=y, yi=yk, vi=sig2k, theta=0, tau2=dl$tau2, method="DL")
alpha <- 0.05
yU <- y[which.min(abs(pval_dl$qy-(1-alpha/2)))]
cim_dl <- as.numeric(dl$b) + c(-1,1)*yU
# SJ with M-estimator
pval_sj <- ptheta_with_M_estimator(qval=y, yi=yk, vi=sig2k, theta=0, tau2=sj$tau2, method="SJ")
yU <- y[which.min(abs(pval_sj$qy-(1-alpha/2)))]
cim_sj <- as.numeric(sj$b) + c(-1,1)*yU
# HKSJ-DL with M-estimator
y <- c(-100:100/1000+dl$ci.lb, -100:100/1000+dl$ci.ub)
pval_hksj_dl <- ptheta_with_M_estimator(qval=y, yi=yk, vi=sig2k, theta=0, tau2=dl$tau2, method="HKSJ-DL")
cim_hksj_dl <- c(y[which.min(abs(pval_hksj_dl$qy - (alpha/2)))], y[which.min(abs(pval_hksj_dl$qy - (1-alpha/2)))])
pval_dl
yU
cim_dl
usethis::use_gpl3_license()
devtools::document()
help(rnorm)
devtools::document()
devtools::document()
devtools::document()
library(metaMest)
